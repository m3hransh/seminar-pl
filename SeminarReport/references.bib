
@article{murali_complete_2023,
	title = {Complete {First}-{Order} {Reasoning} for {Properties} of {Functional} {Programs}},
	volume = {7},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3622835},
	doi = {10.1145/3622835},
	abstract = {Several practical tools for automatically verifying functional programs (e.g., Liquid Haskell and Leon for Scala programs) rely on a heuristic based on unrolling recursive function definitions followed by quantifier-free reasoning using SMT solvers. We uncover foundational theoretical properties of this heuristic, revealing that it can be generalized and formalized as a technique that is in fact
              complete
              for reasoning with combined First-Order theories of algebraic datatypes and background theories, where background theories support decidable quantifier-free reasoning. The theory developed in this paper explains the efficacy of these heuristics when they succeed, explain why they fail when they fail, and the precise role that user help plays in making proofs succeed.},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-11-08},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Murali, Adithya and Peña, Lucas and Jhala, Ranjit and Madhusudan, P.},
	month = oct,
	year = {2023},
	pages = {1063--1092},
	file = {Full Text:/home/mehran/Zotero/storage/HHXGHI8Z/Murali et al. - 2023 - Complete First-Order Reasoning for Properties of Functional Programs.pdf:application/pdf},
}

@inproceedings{vazou_liquidhaskell_2014,
	address = {New York, NY, USA},
	series = {Haskell '14},
	title = {{LiquidHaskell}: experience with refinement types in the real world},
	isbn = {978-1-4503-3041-1},
	shorttitle = {{LiquidHaskell}},
	url = {https://dl.acm.org/doi/10.1145/2633357.2633366},
	doi = {10.1145/2633357.2633366},
	abstract = {Haskell has many delightful features. Perhaps the one most beloved by its users is its type system that allows developers to specify and verify a variety of program properties at compile time. However, many properties, typically those that depend on relationships between program values are impossible, or at the very least, cumbersome to encode within the existing type system. Many such properties can be verified using a combination of Refinement Types and external SMT solvers. We describe the refinement type checker liquidHaskell, which we have used to specify and verify a variety of properties of over 10,000 lines of Haskell code from various popular libraries, including containers, hscolour, bytestring, text, vector-algorithms and xmonad. First, we present a high-level overview of liquidHaskell, through a tour of its features. Second, we present a qualitative discussion of the kinds of properties that can be checked -- ranging from generic application independent criteria like totality and termination, to application specific concerns like memory safety and data structure correctness invariants. Finally, we present a quantitative evaluation of the approach, with a view towards measuring the efficiency and programmer effort required for verification, and discuss the limitations of the approach.},
	urldate = {2024-11-11},
	booktitle = {Proceedings of the 2014 {ACM} {SIGPLAN} symposium on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Vazou, Niki and Seidel, Eric L. and Jhala, Ranjit},
	month = sep,
	year = {2014},
	pages = {39--51},
	file = {Full Text PDF:/home/mehran/Zotero/storage/N4JFL7PI/Vazou et al. - 2014 - LiquidHaskell experience with refinement types in the real world.pdf:application/pdf},
}

@misc{jhala_programming_2020,
	title = {Programming {With} {Refinement} {Types}},
	language = {en},
	url = {https://ucsd-progsys.github.io/liquidhaskell-tutorial/},
	author = {Jhala, Ranjit and Seidel, Eric and Vazou, Niki},
	month = jul,
	year = {2020},
	file = {PDF:/home/mehran/Zotero/storage/35GVUEX9/Jhala et al. - Programming With Refinement Types.pdf:application/pdf},
}

@misc{pd_magnus_forall_2023,
	title = {forall x: {Calgary}},
	url = {https://forallx.openlogicproject.org/html/},
	urldate = {2024-11-13},
	author = {{P.D. Magnus} and {Tim Button} and {Robert Trueman} and {Richard Zach}},
	year = {2023},
	file = {forall x\: Calgary:/home/mehran/Zotero/storage/MVX6GMVL/html.html:text/html},
}

@misc{nikolaj_bjorner_programming_nodate,
	title = {Programming {Z3}},
	url = {https://z3prover.github.io/papers/programmingz3.html},
	author = {{Nikolaj Bjørner} and {Leonardo de Moura} and {Lev Nachmanson} and {Christoph Wintersteiger}},
}

@incollection{clarke_satisfiability_2018,
	address = {Cham},
	title = {Satisfiability {Modulo} {Theories}},
	isbn = {978-3-319-10574-1 978-3-319-10575-8},
	url = {http://link.springer.com/10.1007/978-3-319-10575-8\_11},
	language = {en},
	urldate = {2024-11-20},
	booktitle = {Handbook of {Model} {Checking}},
	publisher = {Springer International Publishing},
	author = {Barrett, Clark and Tinelli, Cesare},
	editor = {Clarke, Edmund M. and Henzinger, Thomas A. and Veith, Helmut and Bloem, Roderick},
	year = {2018},
	doi = {10.1007/978-3-319-10575-8\_11},
	pages = {305--343},
	file = {PDF:/home/mehran/Zotero/storage/QHXZNUPR/Barrett and Tinelli - 2018 - Satisfiability Modulo Theories.pdf:application/pdf},
}

@article{vazou_refinement_2018,
	title = {Refinement reflection: complete verification with {SMT}},
	volume = {2},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3158141},
	doi = {10.1145/3158141},
	shorttitle = {Refinement reflection},
	abstract = {We introduce
              Refinement Reflection
              , a new framework for building {SMT}-based deductive verifiers. The key idea is to reflect the code implementing a user-defined function into the function’s (output) refinement type. As a consequence, at
              uses
              of the function, the function definition is instantiated in the {SMT} logic in a precise fashion that permits decidable verification. Reflection allows the user to write
              equational proofs
              of programs just by writing other programs using pattern-matching and recursion to perform case-splitting and induction. Thus, via the propositions-as-types principle, we show that reflection permits the
              specification
              of arbitrary functional correctness properties. Finally, we introduce a proof-search algorithm called
              Proof by Logical Evaluation
              that uses techniques from model checking and abstract interpretation, to completely automate equational reasoning. We have implemented reflection in Liquid Haskell and used it to verify that the widely used instances of the Monoid, Applicative, Functor, and Monad typeclasses actually satisfy key algebraic laws required to make the clients safe, and have used reflection to build the first library that actually verifies assumptions about associativity and ordering that are crucial for safe deterministic parallelism.},
	pages = {1--31},
	issue = {{POPL}},
	year = {2018},

	journal = {Proceedings of the ACM on Programming Languages},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Vazou, Niki and Tondwalkar, Anish and Choudhury, Vikraman and Scott, Ryan G. and Newton, Ryan R. and Wadler, Philip and Jhala, Ranjit},
	urldate = {2024-12-15},
	date = {2018-01},
	langid = {english},
	file = {PDF:/home/mehran/Zotero/storage/IPS2Q94J/Vazou et al. - 2018 - Refinement reflection complete verification with SMT.pdf:application/pdf},
}
