
@article{murali_complete_2023,
	title = {Complete {First}-{Order} {Reasoning} for {Properties} of {Functional} {Programs}},
	volume = {7},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3622835},
	doi = {10.1145/3622835},
	abstract = {Several practical tools for automatically verifying functional programs (e.g., Liquid Haskell and Leon for Scala programs) rely on a heuristic based on unrolling recursive function definitions followed by quantifier-free reasoning using SMT solvers. We uncover foundational theoretical properties of this heuristic, revealing that it can be generalized and formalized as a technique that is in fact
              complete
              for reasoning with combined First-Order theories of algebraic datatypes and background theories, where background theories support decidable quantifier-free reasoning. The theory developed in this paper explains the efficacy of these heuristics when they succeed, explain why they fail when they fail, and the precise role that user help plays in making proofs succeed.},
	language = {en},
	number = {OOPSLA2},
	urldate = {2024-11-08},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Murali, Adithya and Peña, Lucas and Jhala, Ranjit and Madhusudan, P.},
	month = oct,
	year = {2023},
	pages = {1063--1092},
	file = {Full Text:/home/mehran/Zotero/storage/HHXGHI8Z/Murali et al. - 2023 - Complete First-Order Reasoning for Properties of Functional Programs.pdf:application/pdf},
}

@inproceedings{vazou_liquidhaskell_2014,
	address = {New York, NY, USA},
	series = {Haskell '14},
	title = {{LiquidHaskell}: experience with refinement types in the real world},
	isbn = {978-1-4503-3041-1},
	shorttitle = {{LiquidHaskell}},
	url = {https://dl.acm.org/doi/10.1145/2633357.2633366},
	doi = {10.1145/2633357.2633366},
	abstract = {Haskell has many delightful features. Perhaps the one most beloved by its users is its type system that allows developers to specify and verify a variety of program properties at compile time. However, many properties, typically those that depend on relationships between program values are impossible, or at the very least, cumbersome to encode within the existing type system. Many such properties can be verified using a combination of Refinement Types and external SMT solvers. We describe the refinement type checker liquidHaskell, which we have used to specify and verify a variety of properties of over 10,000 lines of Haskell code from various popular libraries, including containers, hscolour, bytestring, text, vector-algorithms and xmonad. First, we present a high-level overview of liquidHaskell, through a tour of its features. Second, we present a qualitative discussion of the kinds of properties that can be checked -- ranging from generic application independent criteria like totality and termination, to application specific concerns like memory safety and data structure correctness invariants. Finally, we present a quantitative evaluation of the approach, with a view towards measuring the efficiency and programmer effort required for verification, and discuss the limitations of the approach.},
	urldate = {2024-11-11},
	booktitle = {Proceedings of the 2014 {ACM} {SIGPLAN} symposium on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Vazou, Niki and Seidel, Eric L. and Jhala, Ranjit},
	month = sep,
	year = {2014},
	pages = {39--51},
	file = {Full Text PDF:/home/mehran/Zotero/storage/N4JFL7PI/Vazou et al. - 2014 - LiquidHaskell experience with refinement types in the real world.pdf:application/pdf},
}

@misc{jhala_programming_2020,
	title = {Programming {With} {Refinement} {Types}},
	language = {en},
	url = {https://ucsd-progsys.github.io/liquidhaskell-tutorial/},
	author = {Jhala, Ranjit and Seidel, Eric and Vazou, Niki},
	month = jul,
	year = {2020},
	file = {PDF:/home/mehran/Zotero/storage/35GVUEX9/Jhala et al. - Programming With Refinement Types.pdf:application/pdf},
}

@misc{pd_magnus_forall_2023,
	title = {forall x: {Calgary}},
	url = {https://forallx.openlogicproject.org/html/},
	urldate = {2024-11-13},
	author = {{P.D. Magnus} and {Tim Button} and {Robert Trueman} and {Richard Zach}},
	year = {2023},
	file = {forall x\: Calgary:/home/mehran/Zotero/storage/MVX6GMVL/html.html:text/html},
}

@misc{nikolaj_bjorner_programming_nodate,
	title = {Programming {Z3}},
	url = {https://z3prover.github.io/papers/programmingz3.html},
	author = {{Nikolaj Bjørner} and {Leonardo de Moura} and {Lev Nachmanson} and {Christoph Wintersteiger}},
}

@incollection{clarke_satisfiability_2018,
	address = {Cham},
	title = {Satisfiability {Modulo} {Theories}},
	isbn = {978-3-319-10574-1 978-3-319-10575-8},
	url = {http://link.springer.com/10.1007/978-3-319-10575-8\_11},
	language = {en},
	urldate = {2024-11-20},
	booktitle = {Handbook of {Model} {Checking}},
	publisher = {Springer International Publishing},
	author = {Barrett, Clark and Tinelli, Cesare},
	editor = {Clarke, Edmund M. and Henzinger, Thomas A. and Veith, Helmut and Bloem, Roderick},
	year = {2018},
	doi = {10.1007/978-3-319-10575-8\_11},
	pages = {305--343},
	file = {PDF:/home/mehran/Zotero/storage/QHXZNUPR/Barrett and Tinelli - 2018 - Satisfiability Modulo Theories.pdf:application/pdf},
}
