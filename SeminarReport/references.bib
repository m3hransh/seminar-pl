@inproceedings{vazou_liquidhaskell_2014,
	address = {New York, NY, USA},
	series = {Haskell '14},
	title = {{LiquidHaskell}: experience with refinement types in the real world},
	isbn = {978-1-4503-3041-1},
	shorttitle = {{LiquidHaskell}},
	url = {https://dl.acm.org/doi/10.1145/2633357.2633366},
	doi = {10.1145/2633357.2633366},
	abstract = {Haskell has many delightful features. Perhaps the one most beloved by its users is its type system that allows developers to specify and verify a variety of program properties at compile time. However, many properties, typically those that depend on relationships between program values are impossible, or at the very least, cumbersome to encode within the existing type system. Many such properties can be verified using a combination of Refinement Types and external SMT solvers. We describe the refinement type checker liquidHaskell, which we have used to specify and verify a variety of properties of over 10,000 lines of Haskell code from various popular libraries, including containers, hscolour, bytestring, text, vector-algorithms and xmonad. First, we present a high-level overview of liquidHaskell, through a tour of its features. Second, we present a qualitative discussion of the kinds of properties that can be checked -- ranging from generic application independent criteria like totality and termination, to application specific concerns like memory safety and data structure correctness invariants. Finally, we present a quantitative evaluation of the approach, with a view towards measuring the efficiency and programmer effort required for verification, and discuss the limitations of the approach.},
	urldate = {2024-11-11},
	booktitle = {Proceedings of the 2014 {ACM} {SIGPLAN} symposium on {Haskell}},
	publisher = {Association for Computing Machinery},
	author = {Vazou, Niki and Seidel, Eric L. and Jhala, Ranjit},
	month = sep,
	year = {2014},
	pages = {39--51},
	file = {Full Text PDF:/home/mehran/Zotero/storage/N4JFL7PI/Vazou et al. - 2014 - LiquidHaskell experience with refinement types in the real world.pdf:application/pdf},
}

@misc{jhala_programming_2020,
	title = {Programming {With} {Refinement} {Types}},
	language = {en},
	url = {https://ucsd-progsys.github.io/liquidhaskell-tutorial/},
	author = {Jhala, Ranjit and Seidel, Eric and Vazou, Niki},
	month = jul,
	year = {2020},
	file = {PDF:/home/mehran/Zotero/storage/35GVUEX9/Jhala et al. - Programming With Refinement Types.pdf:application/pdf},
}

@misc{nikolaj_bjorner_programming_nodate,
	title = {Programming {Z3}},
	url = {https://z3prover.github.io/papers/programmingz3.html},
	author = {{Nikolaj Bjørner} and {Leonardo de Moura} and {Lev Nachmanson} and {Christoph Wintersteiger}},
}

@incollection{clarke_satisfiability_2018,
	address = {Cham},
	title = {Satisfiability {Modulo} {Theories}},
	isbn = {978-3-319-10574-1 978-3-319-10575-8},
	url = {http://link.springer.com/10.1007/978-3-319-10575-8\_11},
	language = {en},
	urldate = {2024-11-20},
	booktitle = {Handbook of {Model} {Checking}},
	publisher = {Springer International Publishing},
	author = {Barrett, Clark and Tinelli, Cesare},
	editor = {Clarke, Edmund M. and Henzinger, Thomas A. and Veith, Helmut and Bloem, Roderick},
	year = {2018},
	doi = {10.1007/978-3-319-10575-8\_11},
	pages = {305--343},
	file = {PDF:/home/mehran/Zotero/storage/QHXZNUPR/Barrett and Tinelli - 2018 - Satisfiability Modulo Theories.pdf:application/pdf},
}

@article{vazou_refinement_2018,
	title = {Refinement reflection: complete verification with {SMT}},
	volume = {2},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3158141},
	doi = {10.1145/3158141},
	shorttitle = {Refinement reflection},
	abstract = {We introduce
              Refinement Reflection
              , a new framework for building {SMT}-based deductive verifiers. The key idea is to reflect the code implementing a user-defined function into the function’s (output) refinement type. As a consequence, at
              uses
              of the function, the function definition is instantiated in the {SMT} logic in a precise fashion that permits decidable verification. Reflection allows the user to write
              equational proofs
              of programs just by writing other programs using pattern-matching and recursion to perform case-splitting and induction. Thus, via the propositions-as-types principle, we show that reflection permits the
              specification
              of arbitrary functional correctness properties. Finally, we introduce a proof-search algorithm called
              Proof by Logical Evaluation
              that uses techniques from model checking and abstract interpretation, to completely automate equational reasoning. We have implemented reflection in Liquid Haskell and used it to verify that the widely used instances of the Monoid, Applicative, Functor, and Monad typeclasses actually satisfy key algebraic laws required to make the clients safe, and have used reflection to build the first library that actually verifies assumptions about associativity and ordering that are crucial for safe deterministic parallelism.},
	pages = {1--31},
	issue = {{POPL}},
	year = {2018},

	journal = {Proceedings of the ACM on Programming Languages},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Vazou, Niki and Tondwalkar, Anish and Choudhury, Vikraman and Scott, Ryan G. and Newton, Ryan R. and Wadler, Philip and Jhala, Ranjit},
	urldate = {2024-12-15},
	date = {2018-01},
	langid = {english},
	file = {PDF:/home/mehran/Zotero/storage/IPS2Q94J/Vazou et al. - 2018 - Refinement reflection complete verification with SMT.pdf:application/pdf},
}

@misc{noauthor_ucsd-progsyslh-plugin-demo_2024,
	title = {ucsd-progsys/lh-plugin-demo},
	rights = {{BSD}-3-Clause},
	url = {https://github.com/ucsd-progsys/lh-plugin-demo},
	abstract = {A small package that demonstrates how to use {LiquidHaskell} as a {GHC} plugin},
	publisher = {ucsd-progsys},
	urldate = {2025-02-02},
	date = {2024-10-26},
	note = {original-date: 2020-06-24T23:10:49Z},
}

@article{vazou_refinement_2014,
	title = {Refinement Types For Haskell},
	volume = {49},
	issn = {978-1-4503-2873-9},
	doi = {10.1145/2628136.2628161},
	abstract = {{SMT}-based checking of refinement types for call-by-value languages is a well-studied subject. Unfortunately, the classical translation of refinement types to verification conditions is unsound under lazy evaluation. When checking an expression, such systems implicitly assume that all the free variables in the expression are bound to values. This property is trivially guaranteed by eager, but does not hold under lazy, evaluation. Thus, to be sound and precise, a refinement type system for Haskell and the corresponding verification conditions must take into account which subset of binders actually reduces to values. We present a stratified type system that labels binders as potentially diverging or not, and that (circularly) uses refinement types to verify the labeling. We have implemented our system in {LIQUIDHASKELL} and present an experimental evaluation of our approach on more than 10,000 lines of widely used Haskell libraries. We show that {LIQUIDHASKELL} is able to prove 96\% of all recursive functions terminating, while requiring a modest 1.7 lines of termination-annotations per 100 lines of code.},
	journal = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{ACM} {SIGPLAN} Notices},
	author = {Vazou, Niki and Seidel, Eric and Jhala, Ranjit and Vytiniotis, Dimitrios and Peyton Jones, Simon},
  year = {2014},
	date = {2014-08-19},
}

@misc{niki_blog_2016,
  author = {Vazou, Niki},
	title = {{Haskell as a Theorem Prover} Blog},
	url = {https://ucsd-progsys.github.io/liquidhaskell-blog/2016/09/18/refinement-reflection.lhs},
	abstract = {{LiquidHaskell} Blog},
	titleaddon = {{LiquidHaskell} Blog},
	urldate = {2025-02-03},
  year = {2016},
}


@article{wadler_propositions_2015,
	title = {Propositions as types},
	volume = {58},
	issn = {0001-0782},
	url = {https://dl.acm.org/doi/10.1145/2699407},
	doi = {10.1145/2699407},
	abstract = {Connecting mathematical logic and computation, it ensures that some aspects of programming are absolute.},
	pages = {75--84},
	number = {12},
	journal= {Commun. {ACM}},
	author = {Wadler, Philip},
	urldate = {2025-02-03},
	date = {2015-11-23},
  year = {2015},
	file = {Full Text PDF:/home/mehran/Zotero/storage/PHW6DIQS/Wadler - 2015 - Propositions as types.pdf:application/pdf},
}

@misc{niki_lecture_2024,
  title = {{Programming with Refinement Types} Lecture},
  author = {Vazou, Niki},
  url = {https://nikivazou.github.io/lh-course},
  date = {2024-03-15},
}

@misc{SoftwareVerification2024,
  title = {Software Verification},
  booktitle = {Wikipedia},
  date = {2024-12-11T00:42:58Z},
  url = {https://en.wikipedia.org/w/index.php?title=Software_verification&oldid=1262364177},
  urldate = {2025-02-26},
  abstract = {Software verification is a discipline of software engineering, programming languages, and theory of computation whose goal is to assure that software satisfies the expected requirements.},
  langid = {english},
  annotation = {Page Version ID: 1262364177},
  file = {/home/mehran/Zotero/storage/P7VJKY38/Software_verification.html}
}
