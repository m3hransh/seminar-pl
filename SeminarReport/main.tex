\documentclass[]{rptuseminar}

% Specify that the source file has UTF8 encoding
\usepackage[utf8]{inputenc}
% Set up the document font; font encoding (here T1) has to fit the used font.
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% Load language spec
\usepackage[american]{babel}
% German article --> ngerman (n for »neue deutsche Rechtschreibung«)
% British English --> english

% Ffor bibliography and \cite
\usepackage{cite}

% AMS extensions for math typesetting
\usepackage[intlimits]{mathtools}
\usepackage{amssymb}
% ... there are many more ...


% Load \todo command for notes
\usepackage{todonotes}
% Sebastian's favorite command for large inline todonotes
% Caveat: does not work well with \listoftodos
\newcommand\todoin[2][]{\todo[inline, caption={2do}, #1]{
		\begin{minipage}{\linewidth-1em}\noindent\relax#2\end{minipage}}}

% Load \includegraphics command for including pictures (pdf or png highly recommended)
\usepackage{graphicx}

% Typeset source/pseudo code
\usepackage{listings}

% Load TikZ library for creating graphics
% Using the PGF/TikZ manual and/or tex.stackexchange.com is highly adviced.
\usepackage{tikz}
% Load tikz libraries needed below (see the manual for a full list)
\usetikzlibrary{automata,positioning}

% Load \url command for easier hyperlinks without special link text
\usepackage{url}

% Load support for links in pdfs
\usepackage{hyperref}

% Defines default styling for code listings
% \definecolor{pink}{rgb}{}
\definecolor{green_ulises}{rgb}{0.2,0.75,0}
\lstdefinelanguage{smtlib2} {
  morekeywords={set-logic, declare-const, assert, check-sat, get-model},
  sensitive=true,
  morecomment=[l]{;},
  morestring=[b]"
}

\lstset{%
  columns=flexible,
  keepspaces=true,
  tabsize=3,
  basicstyle={\fontfamily{tx}\ttfamily\small},
  stringstyle=\color{green_ulises},
  commentstyle=\color{black!80}
  identifierstyle=\slshape{},
  keywordstyle=\bfseries,
  numberstyle=\small\color{pink},
  backgroundcolor=\color{gray!5},
  numberblanklines=false,
  inputencoding={utf8},
  showstringspaces=false,
  belowskip=-1mm,
  escapeinside={//*}{\^^M} % Allow to set labels and the like in comments
}

% Defines a custom environment for indented shell commands
\newenvironment{displayshellcommand}{%
	\begin{quote}%
	\ttfamily%
}{%
	\end{quote}%
}

%%%%%%%%%%%%%%%%
\lstnewenvironment{haskell}{
  \vspace{1em}%
  \lstset{
    language=Haskell,
    columns=flexible,
    keepspaces=true,
    tabsize=3,
    basicstyle={\fontfamily{tx}\ttfamily\small},
    stringstyle=\color{green_ulises},
    commentstyle=\color{black!80},
    identifierstyle=\slshape{},
    keywordstyle=\bfseries,
    numberstyle=\small\color{pink},
    backgroundcolor=\color{gray!5},
    numberblanklines=false,
    inputencoding={utf8},
    belowskip=-1mm,
    escapeinside={//*}{\^^M} % Allow to set labels and the like in comments
  }
}{
  \vspace{1em}
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\textbf{Liquid}{H}\textbf{askell}}
\event{Seminar: Programming Languages in Winter term 2024/2025}
\author{Mehran Shahidi, Saba Safarnezhad
  \institute{Rheinland-Pfälzische Technische Universität Kaiserslautern-Landau, Department of Computer Science}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  This report provides a brief overview of \texttt{LiquidHaskell}, a tool that extends Haskell with refinement types. 
  Refinement types are types that extend the expressiveness of Haskell's type system by providing predicates that can specify invariants of the program. 
  This report illustrates features of \texttt{LiquidHaskell} through a small formalization and demonstrates its application with several examples. 
  Finally, we discuss its limitations and compare it with other tools.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:introduction}
Two main trends in deductive verifiers are \textit{Satisfiability Modulo Theory} (SMT)-based and \textit{Typed-Theory} (TT)-based approaches. 
TT-based verifiers leverage type-level computation (normalization) to facilitate principled reasoning about terminating user-defined functions,
whereas SMT-based verifiers use, among other tools, SMT solvers to check the satisfiability of universally-quantified axioms—axioms 
that encode the semantics of user-defined functions within a specific theory (e.g., linear arithmetic, strings, sets, or bitvectors).
Refinement types, and in particular the technique known as Refinement Reflection (see Section \ref {sec:reflection}) combine the best of both worlds by fusing types with SMT based validity checking \cite{vazou_refinement_2018}.

In this report, we focus on \texttt{LiquidHaskell}, a tool that extends Haskell with refinement types.
After a short overview of refinement types and SMT solvers in section \ref{sec:background}, 
we explain \texttt{LiquidHaskell}'s features in section \ref{sec:lh}. Then, in section \ref{sec:example}, we provide an example of verifying \texttt{Insertion Sort}. 
Finally in section \ref{sec:conclusions} we 
discuss the limitations of \texttt{LiquidHaskell} and compare it with other tools.

% E.~g.~ 
% ``quoting'' is done by using two backticks and two single quotes

\section{Overview}
\label{sec:background}

\subsection{Refinement Types}  
Refinement types extend conventional type systems by attaching logical predicates to types.
This allows for more precise type specifications and can potentially detect more errors 
at compile time \cite{vazou_refinement_2014}.

Consider the following function:

\begin{haskell}  
divide :: Int -> Int -> Int  
\end{haskell} 

The standard type system ensures that the function \texttt{divide} takes two integers and 
returns an integer. For example, if we call \texttt{divide} with arguments of type 
\texttt{Bool}, the type system will show the error at compile time. 
However, it does not detect the error if the function is called with the second 
argument being zero.

In a refinement type system, we can define more precise types as follows: 

\begin{haskell}  
type Pos = {v:Int | v > 0}  
type Nat = {v:Int | v >= 0}  
\end{haskell}  

These are refinements of the basic \texttt{Int} type, where the logical predicates state 
that \texttt{v} is strictly positive (\texttt{Pos}) and non-negative (\texttt{Nat}), 
respectively. We can use these refinement types to annotate functions with 
preconditions and postconditions. For instance:

\begin{haskell}  
divide :: Nat -> Pos -> Int  
\end{haskell}  

This type signature specifies that the function \texttt{divide} takes a non-negative 
integer as its first argument and a positive integer as its second argument. Consequently, if we call
\texttt{divide}, the type checker will verify if the specifications meet.
For instance, the following function is rejected by the type checker:

\begin{haskell}  
bad :: Nat -> Nat -> Int 
bad x y = x `div` y
\end{haskell} 
To be able to verify this, the refinement type system translates the annotation into a so-called
\textit{subtyping} query as follows \cite{vazou_refinement_2014}:

\begin{equation*}
\label{eq:subtyping}
\begin{matrix}
x : \{\,x : \mathrm{Int} \mid x \ge 0\}, \\

y : \{\,y : \mathrm{Int} \mid y \ge 0\}
\end{matrix}
\;\vdash\;
\{\,y : \mathrm{Int} \mid y \ge 0\}
\preceq
\;\{\,v : \mathrm{Int} \mid v > 0\}.
\end{equation*}

The notation $\Gamma  \vdash \tau_1 \preceq \tau_2$ means that in the type environment $\Gamma$, 
$\tau_1$ is a subtype of $\tau_2$. The subtype query states, given the type environment in which 
$x$ and $y$ have type \texttt{Nat}, the type of $y$ should be a subtype of \texttt{divide}'s second parameter $v$ where $v$ is a positive integer.
The type system then translates this query into a verification condition (VC)- logical formulas whose validity ensures that the type
specification is satisfied \cite{vazou_refinement_2014}.
The translation of the subtyping query to VCs is shown in Figure \ref{fig:notation}. Based on this
translation we would have the following VC:

\begin{equation}
\label{eq:subtyping-vc}
(x \ge 0) \land (y \ge 0)  \Rightarrow (v \ge 0) \Rightarrow (v > 0)
\end{equation}
\begin{figure}[htbp]
  \centering
  \renewcommand{\arraystretch}{1.4}
  \begin{tabular}{@{}ll@{}}
    \( (|\Gamma \vdash b_1 \preceq b_2|) \) & \( \doteq (|\Gamma|) \Rightarrow (|b_1|) \Rightarrow (|b_2|) \) \\[1ex]
    \( (|\{x:\mathrm{Int} \mid r\}|) \) & \( \doteq r \) \\[1ex]
    \( (|x:\{v:\mathrm{Int} \mid r\}|) \) & \( \doteq \text{``x is a value''} \Rightarrow r[x/v] \) \\[1ex]
    \( (|x:(y:\tau_y \to \tau)|) \) & \( \doteq \text{true} \) \\[1ex]
    \( (|x_1:\tau_1,\ldots,x_n:\tau_n|) \) & \( \doteq (|x_1:\tau_1|) \land \cdots \land (|x_n:\tau_n|) \)
  \end{tabular}
  \caption{Notation: Translation to VCs \cite{vazou_refinement_2014}}
  \label{fig:notation}
\end{figure}

This VC is meant to express that, under the environment where x and y are non-negative, 
the property “if v is non-negative then v is strictly positive" must hold. 
This is unsatisfiable since 0 is non-negative but not strictly positive, which is what the verifier 
should detect for the \texttt{bad} function.

Refinement type systems are designed to exclude any arbitrary functions and only include formulas
from decidable logics\cite{vazou_refinement_2014}. These VCs are then passed to an SMT solver to check their satisfiability.
In this case, the SMT solver would reject the \texttt{bad} function as the VC is unsatisfiable.
In the next section, we provide a brief introduction to SMT solvers and how they can be used in 
the context of \texttt{LiquidHaskell}.

\subsection{SMT Solvers}
SAT solvers are designed to determine the satisfiability of Boolean formulas\cite{clarke_satisfiability_2018}. 
For example, consider the following formula that is intended to be solved by SAT solvers:
\begin{equation}
  \varphi = (x \lor y) \land (\lnot x \lor z)
\end{equation}

A SAT solver can check the satisfiability of the formula \(\varphi\) by checking if there is an assignment to the variables 
\(x, y, z\) such that the statement evaluates to \(true\).
For instance, the assignment \(x = true, y = false, z = true\) satisfies the formula \(\varphi\).

SMT solvers extend SAT solvers by incorporating additional theories—such as equality, integer arithmetic, real arithmetic, 
arrays, and lists—into Boolean logic \cite{clarke_satisfiability_2018}.
As an example, consider the following formula that contains variables requiring arithmetic reasoning:

\begin{equation}
  x + y \leq 10 \quad \land \quad x = y - 7
\end{equation}


\texttt{LiquidHaskell} uses SMT solvers to check the satisfiability of verification conditions (VCs) generated from refinement types.  
In the following section, we take a closer look at the Z3 SMT solver through some illustrative examples.

\subsubsection{Applications and Examples of Z3}

Z3 is a powerful SMT solver equipped with specialized algorithms for solving background theories such as linear arithmetic, bit-vectors, and arrays. It allows users to express constraints using the SMT-LIB2 language, which is the standard input format for SMT solvers. Additionally, Z3 provides APIs for a variety of programming languages, including Python, C++, Haskell, and Java~\cite{nikolaj_bjorner_programming_nodate}.

To use \texttt{LiquidHaskell}, at least one of the SMT solvers it supports must be installed—namely, Z3, CVC4, or MathSat. Among these, Z3 is the most thoroughly tested and widely used with \texttt{LiquidHaskell}~\cite{jhala_programming_2020}.

To demonstrate Z3's capabilities, we will express and solve a simple satisfiability problem using both \texttt{SMT-LIB2} and Python.
Consider the following SAT problem (Equation~\ref{eq:example-sat}) involving three clauses.  
We aim to determine whether there exists an assignment of Boolean values to \( \mathit{Tie} \) and \( \mathit{Shirt} \) such that the formula holds:

\vspace{1em}
\begin{equation}
  \label{eq:example-sat}
  (\mathit{Tie} \lor \mathit{Shirt}) \land (\lnot \mathit{Tie} \lor \mathit{Shirt}) \land (\lnot \mathit{Tie} \lor \lnot \mathit{Shirt})
\end{equation}

This formula can be expressed in \texttt{SMT-LIB2} as follows:

\begin{lstlisting}[language=lisp, label={lst:smtlib2}]
(set-logic QF_UF)
(declare-const Tie Bool)
(declare-const Shirt Bool)

(assert (or Tie Shirt))
(assert (or (not Tie) Shirt))
(assert (or (not Tie) (not Shirt)))

(check-sat)
(get-model)
\end{lstlisting}

\vspace{1em}

This \texttt{SMT-LIB2} script sets up the problem, declares the variables, asserts the constraints, checks for satisfiability, 
and retrieves the model.
Alternatively, we can use Z3’s Python API to express and solve the same problem programmatically:

\begin{lstlisting}[language=Python, label={lst:z3python}]
from z3 import *

Tie = Bool('Tie')
Shirt = Bool('Shirt')
clauses = [
    Or(Tie, Shirt),
    Or(Not(Tie), Shirt),
    Or(Not(Tie), Not(Shirt))
]

solver = Solver()
solver.add(clauses)

if solver.check() == sat:
    print("Satisfiable")
    print(solver.model())
else:
    print("Unsatisfiable")
\end{lstlisting}

\vspace{1em}

When we run code fragment written in \texttt{SMT-LIB2}, Z3 responds:
\begin{lstlisting} [language=SMTlIB2]
 sat
 (model
   (define-fun Tie () Bool false)
   (define-fun Shirt () Bool true)
 )
\end{lstlisting}
\vspace{1em}


When calling \texttt{solver.check()}, the solver determines that the assertions are satisfiable
(sat)—meaning there is a way to assign values to the \(Tie\) and \(Shirt\) that make all the 
conditions true. One possible solution is \(Tie = false\) and \(Shirt = true\), which can be retrieved using \texttt{solver.model()}.
\vspace{1em}


\subsubsection{Combining Theories in Z3}

A key feature of modern SMT solvers such as Z3 is their ability to reason across multiple logical theories simultaneously. 
This capability is critical in software verification tasks, where properties of programs often involve 
arithmetic constraints, memory access patterns, and abstract functions. 
The following example demonstrates Z3’s theory combination mechanism through a small but non-trivial 
constraint involving linear arithmetic, arrays, and uninterpreted functions \cite{nikolaj_bjorner_programming_nodate}.

\begin{lstlisting}[language=Python, label={lst:combined-theories}]
Z = IntSort()
f = Function('f', Z, Z)
x, y, z = Ints('x y z')
A = Array('A', Z, Z)
fml = Implies(x + 2 == y, f(Store(A, x, 3)[y - 2]) == f(y - x + 1))
solve(Not(fml))

\end{lstlisting}
\vspace{1em}

The code above encodes a formula in Z3’s Python API and checks whether its negation is satisfiable. The solver returns \texttt{unsat}, indicating that the negated formula is not satisfiable, and therefore the original implication holds in all models. This deduction results from Z3’s ability to simultaneously reason within and across several background theories.

First, the theory of \emph{Linear Integer Arithmetic (LIA)} governs constraints such as \(x + 2 = y\) and expressions like \(y - x + 1\), which appear in both the antecedent and consequent of the implication. This theory enables Z3 to reason about numeric relationships and preserve equality propagation across expressions.

Second, the formula involves an array operation: \texttt{Store}(A, x, 3)[y - 2]. In Z3’s semantics, this corresponds to a functional update of array \(A\) at index \(x\), followed by a read at index \(y - 2\). The semantics of the \texttt{Store} and \texttt{Select} operators are formally defined using a conditional expression:
\[
    \texttt{Store}(A, x, 3)[y - 2] \equiv 
    \begin{cases}
    3 & \text{if } y - 2 = x \\
    A[y - 2] & \text{otherwise}
    \end{cases}
\]
This is expressed in Z3 using the \texttt{ite} operator, short for \emph{if-then-else}.

Finally, the function symbol \(f\) is treated as an \emph{uninterpreted function}—that is, a function with no specific definition, but one which satisfies the axiom of functional congruence: for all \(a\) and \(b\), if \(a = b\) then \(f(a) = f(b)\). This allows Z3 to perform symbolic reasoning on applications of \(f\), relying solely on equality relationships between its arguments.

What makes this example particularly illustrative is that the solver must combine these theories coherently. The antecedent provides a numeric constraint \(x + 2 = y\), which is used to simplify the expression \(y - 2 = x\) and resolve the result of the array access. This index then determines the value passed to the function \(f\), which is subsequently compared to another function application involving arithmetic. Through this process, Z3 propagates equalities, evaluates array expressions, and applies congruence rules for uninterpreted functions—eventually concluding that the equality in the implication must hold.



This example highlights Z3's ability to reason across multiple logical domains in a unified manner. By combining arithmetic reasoning, memory modeling via arrays, and abstraction through uninterpreted functions, Z3 is able to resolve complex constraints that arise in software analysis. Such theory combination is especially valuable in verifying real-world programs, where data structures, numeric computations, and abstract logic often interact in nontrivial ways.

In the following section, we explore how this kind of logical reasoning is applied in practice using \texttt{LiquidHaskell}.
\texttt{LiquidHaskell} allows programmers to embed logical properties directly into type annotations, and automatically verifies them using the same kind of background theories we have just examined. We begin by showing how to set up \texttt{LiquidHaskell} in a Haskell project and introduce its key verification features.
\section{Working with \textbf{LiquidHaskell}}
\label{sec:lh}
In this section, we will explain how to work with \texttt{LiquidHaskell}.
\texttt{LiquidHaskell} is available as a GHC plugin. To use it in your Haskell project, you need to add its dependencies to cabal file as following \cite{noauthor_ucsd-progsyslh-plugin-demo_2024}:

\vspace{1em}
\begin{lstlisting}
 cabal-version: 1.12

 name:           lh-plugin-demo
 version:        0.1.0.0
 ...
 ...
   build-depends:
       liquid-prelude,
       liquid-vector,
       liquidhaskell,
       base,
       containers,
       vector
   default-language: Haskell2010
   ghc-options:  -fplugin=LiquidHaskell
\end{lstlisting}
\vspace{1em}

With these dependencies, \texttt{LiquidHaskell} can check your program at compile time or through a code linter in your preferred IDE.  


\subsection{Type Refinement}
As mentioned in Section \ref{sec:background}, refinement types are types that extend the expressiveness 
of type system by providing predicates that can specify invariants of the program.

\texttt{LiquidHaskell} uses Logically Qualified Data Types (Liquid Types) \cite{rondonLiquidTypes2008}, 
with some modifications to ensure soundness under lazy evaluation, to specify these refinements in 
Haskell \cite{vazou_refinement_2014}.

It ensures that type checking remains decidable and efficient by generating verification conditions (VCs) 
that are both decidable and efficiently solvable by SMT solvers \cite{vazou_refinement_2014}.

The Liquid type annotations are provided by the programmer in the source file as Haskell comments. Consider the following example:

\begin{haskell}
 {-@ type Nat = {v:Int | 0 <= v} @-}
\end{haskell}

If you configure your IDE to use the Haskell LSP, it will display the following error if you attempt to assign a negative 
number to a variable of type \texttt{Nat}:

\begin{haskell}
 {-@ x :: Nat @-}
 x = -1
 >>> typecheck: Liquid Type Mismatch
   .
   The inferred type
     VV : {v : GHC.Types.Int | v == GHC.Num.negate (GHC.Types.I# 1)}
   .
   is not a subtype of the required type
     VV : {VV##493 : GHC.Types.Int | VV##493 >= 0}
   .
   Constraint id 2
\end{haskell}

The error message indicates that the inferred type of the variable \texttt{x} is not a subtype of the 
required type. \texttt{LiquidHaskell} employs liquid typing rules—including the subtyping rule 
discussed in Section \ref{sec:background}—to infer these types.

Particularly, in \texttt{LiquidHaskell}, integers and other constants (e.g., booleans, character, etc.) are given a
singleton type, meaning a type that has only one value \cite{niki_lecture_2024}. For instance, the liquid typing rule for integers is:

\[
\frac{
}{
\Gamma \vdash i: \{Int \mid v = i\}
} 
\quad (\mathit{T-Int})
\]

Combined with the following subtyping rule:

\[
\frac{
 \Gamma \vdash e: \tau_1  \quad \Gamma  \vdash \tau_1 \preceq \tau_2
}{
 \Gamma \vdash e: \tau_2 
}
\quad (\mathit{SUBTYPE})
\]

Refinement type checker, based on the \(\mathit{T-Int}\) rule, expects that expression \(-1\) should have type \(\{Int \mid v = -1\}\) 
and then it should be a subtype of Nat type (assignment to variable of type Nat). 
According to the translation of the subtyping query into verification conditions (see Figure \ref{eq:subtyping-vc}), 
the type checker generates the following VC:
\[ -1 = v \Rightarrow v \geq 0  \] 
which in turn the SMT sovler finds unsatisfiable.



\subsection{Function Types}

Refinement types allow defining function preconditions and postconditions\cite{jhala_programming_2020}. 
For example, consider the following function:

\begin{haskell}
 tail :: [a] -> [a]
 tail (_:xs) = xs
 tail [] = error "tail: empty list"
\end{haskell}

The function defined above is a partial function because it does not handle the case when the list is empty. 
Typical Haskell types allow the introduction of the \texttt{Maybe} type to loosen the output type or probably using more stronger type for input
such as \texttt{NonEmpty} for making the function total.  
The former approach, postpone handling to another part of the program \cite{jhala_programming_2020}, while the second approach
needs the user introduce handling of empty list at some point earlier in the program.
Using refinement types, we can define the type of tail function as follows:

\begin{haskell}
{-@ tail :: {v:[a] | 0 < len v} -> [a] @-}
 tail :: [a] -> [a]
 tail (x:_) = x
\end{haskell}

This type definition specifies that the input list should have a length greater than zero.
\texttt{len} is a special function that is defined in the refinement logic and returns the length of the list.
In the Section \ref{sec:reflection}, we will show how to define and use user-defined functions in the refinement logic.
\texttt{LiquidHaskell} will check this condition at compile time and issue an error if the condition is not met.
Consider the following example:
\begin{haskell}
x = tail []
\end{haskell}
\texttt{LiquidHaskell} check that the type 
\begin{equation*}
  \{v : [a] \mid v == \text{GHC.Types.[ ]}\quad \&\& \text{ len } v == 0 \quad \&\&  \text{ len } v >= 0\}
\end{equation*}
is a subtype of the required type 

\begin{equation*}
  \{v : [a] \mid  \text{ len } v > 0\}
\end{equation*}
and issue an error if the condition is not met. However, in some cases  
like following the refinement checker can not verify the function call
and give an error:
\begin{haskell}
 x :: [Int]
 x = tail (tail [1, 2])
\end{haskell}

When checking the function call, \texttt{LiquidHaskell} doesn't 
look into the body of the function to see if the first application 
of the \textit{tail} gives the valid non-empty list to the second \textit{tail}.
To allow \texttt{LiquidHaskell} consider the above example as safe, 
we need to also specify the post-condition for our function as following:


\begin{haskell}
 {-@ tail :: xs: {v:[a] | 0 < len v} -> {v:[a] | len v == len xs - 1} @-}
 tail :: [a] -> [a]
 tail (x:_) = x
\end{haskell}

This way, \texttt{LiquidHaskell} can reason about the output of the functions as well
and gives more information to information to the type checker to work with.
\subsection{Refined Data Types}
In the above examples, we saw how refinements of input and output of function allow us to have stronger arguments about our program. 
We can take this further by refining the data types. Consider the following example \cite{jhala_programming_2020}:

\begin{haskell}
  data Slist a = Slist { size :: Int, elems :: [a] }

  {-@ data Slist a = Slist { size :: Nat, elems :: {v:[a] | len v == size} } @-}
\end{haskell}

This refined \textit{Slist} data type ensures the stored `size` always matches the length of the `elems` list, 
as formalized in the refinement annotation \cite{jhala_programming_2020}. 
This ensures that the size of the list is always correct.

The only thing that is missing is the definition of \textit{len}. Fortunately, this function has already reflected by
\texttt{LiquidHaskell}. In the following section, we show how can we use reflection or measure directives to define and execute any user-defined Haskell function in the refinement logic and
reason about them.

\subsection{Lifting Functions to the Refinement Logic}
\label{sec:reflection}
When our programs become more complex, we need to define our own functions in the refinement logic and reason about
a function within another function. Refinement Reflection allows deep specification and verification by 
reflecting the code implementing a Haskell function into the function’s output refinement type \cite{niki_blog_2016}.
There are two ways to define and reason about a function in the refinement logic: \texttt{reflection} and \texttt{measure}. 

\texttt{Measure} can be used on a function with one argument that is pattern-matched in the function body. Then,
\texttt{LiquidHaskell} copies the function to the refinement logic, adds a refinement type to the constructor of the function's argument, and emits inferred global
invariants related to the refinement \cite{niki_lecture_2024}. Consider the following example:

\begin{haskell}
data Bag a = Bag { toMap :: M.Map a Int } deriving Eq
{-@ measure bag @-}
{-@ bag :: Ord a => List a -> Bag a @-}
bag :: (Ord a) => List a -> Bag a
bag Nil = B.empty
bag (Cons x xs) = B.put x (bag xs)
\end{haskell}

This code adds the bag refinement type to the List data type. The \texttt{measure} directive is used to define the \texttt{bag} function,
which is then copied to the refinement logic. It means that now the type of list constructors would have:

\begin{haskell}
Nil  :: {v:List a | bag v = B.empty}
Cons :: x:a -> l:List a -> {v:List a | bag v = B.put x (bag l)}
\end{haskell}

So then we can use the \texttt{bag} function in the refinement logic to reason about the program. 
For instance, in the following example, we can use the \texttt{bag} function to reason about the program:

\begin{haskell}
{-@ equalBagExample1 :: { bag(Cons 1 (Cons 3 Nil)) ==  bag( Cons 2 Nil) } @-}

>>    VV : {v : () | v == GHC.Tuple.Prim.()}
>>    .
>>    is not a subtype of the required type
>>      VV : {VV##2465 : () | bag (Cons 1 (Cons 3 Nil)) == bag (Cons 2 Nil)}
\end{haskell}

The $\{x = y\}$ is shorthand for $\{ v : () \mid x = y \}$, where $x$ and $y$ are expressions.
Note that equality for bags is defined as the equality of the underlying maps that already have a built-in equality function.
\texttt{LiquidHaskell} can reason about the equality of bags by using the equality of the underlying maps and issuing a type error if the bags are not equal.
If we define multiple measures for the same data type the refinements are conjoined together \cite{niki_lecture_2024}.



Reflection is another useful feature that allows the user to define a function in the refinement logic, providing
the SMT solver with the function's behavior \cite{vazou_refinement_2018}. 
This has the advantage of allowing the user to define a function that is not pattern-matched in the function body.
Additionally, with the use of a library of combinators provided by \texttt{LiquidHaskell}, we can leverage the existing programming constructs to 
prove the correctness of the program and use the principle of propositions-as-types (known as Curry-Howard isomorphism)\cite{vazou_refinement_2018}\cite{wadler_propositions_2015}.

\begin{haskell}
{-@ infixr ++ @-}
{-@ reflect ++ @-}

{-@ (++) :: xs:[a] -> ys:[a] -> { zs:[a] | len zs == len xs + len ys } @-}
(++) :: [a] -> [a] -> [a]
[] ++ ys = ys
(x : xs) ++ ys = x : (xs ++ ys)
\end{haskell}

The \texttt{++} function is defined in the refinement logic using the \texttt{reflect} directive.
Now we can use the \texttt{++} function in the refinement logic to reason about the program.
In the following subsection, we will show how to use \texttt{LiquidHaskell} to verify that  the \texttt{++} function is associative.

\subsection{Verification}
\texttt{LiquidHaskell} allows structure proofs to follow the style of calculational or equational reasoning popularized in classic texts
and implemented in proof assistants like Coq and Agda . It is equipped with a family of equation combinators
for logical operators in the theory QF-UFLIA \cite{vazou_refinement_2018}.
In the following example, we show how to use these combinators to verify that the \texttt{++} function is associative:

\begin{haskell}
{-@ assoc :: xs:[a] -> ys:[a] -> zs:[a] 
  -> { v: () | (xs ++ ys) ++ zs = xs ++ (ys ++ zs) } @-}
assoc :: [a] -> [a] -> [a] -> ()
assoc [] ys zs =
  ([] ++ ys)
    ++ zs
    === ys
    ++ zs
    === []
    ++ (ys ++ zs)
    *** QED

assoc (x : xs) ys zs =
  ((x : xs) ++ ys) ++ zs
    ===  x : (xs ++ ys) ++ zs
    === x
    : ((xs ++ ys) ++ zs)
      ? assoc xs ys zs
      === (x : xs)
      ++ (ys ++ zs)
      *** QED
\end{haskell}

These combinators are defined as follows:
\begin{haskell}
  (===) :: x: a -> y: { a | x = y }  -> { v: a | v = x }
  data QED = QED
  (***) :: a -> QED -> ()
\end{haskell}

As you can see, some of the steps in the proof seem trivial if we are able to unfold the definition of the \texttt{++} function.
For this purpose, \texttt{LiquidHaskell} provides \texttt{Proof by Logical Evaluation} (PLE) which allows us to unfold the definition of the function.
The key idea in PLE is to mimic type-level computation within SMT-logics by representing the function in a guarded form and repeatedly unfolding function
application terms by instantiating them with their definition corresponds to an enabled guard \cite{vazou_refinement_2018}.

\section{Example Application}
\label{sec:example}

In this section, we discuss the insertion sort algorithm and how to verify its functional correctness using \texttt{LiquidHaskell}.  
We take an intrinsic approach, leveraging refinement types so that we do not need to prove correctness separately.  
Insertion sort is a simple algorithm that builds a sorted list by inserting one element at a time.  
Using \texttt{LiquidHaskell}, we aim to ensure that the sorted list is both ordered and a permutation of the input.  

\subsection{Definition of Insertion Sort}

Insertion sort is implemented in Haskell with two main components: 
the \texttt{insert} function, which places an element in its correct position in a sorted list, 
and the \texttt{insertSort} function, which recursively sorts the input list. Below is the Haskell implementation:

\begin{haskell}
{-@ LIQUID "--reflection" @-}
{-@ LIQUID "--ple" @-}

module InsertionSort where

data List a = Nil | Cons a (List a) deriving (Eq, Show)

{-@ reflect insert @-}
insert :: (Ord a) => a -> List a -> List a
insert x Nil = Cons x Nil
insert x (Cons y ys)
  | x <= y    = Cons x (Cons y ys)
  | otherwise = Cons y (insert x ys)

{-@ reflect insertSort @-}
insertSort :: (Ord a) => List a -> List a
insertSort Nil = Nil
insertSort (Cons x xs) = insert x (insertSort xs)
\end{haskell}

\subsection{Specification}

To verify the correctness of insertion sort, we define specifications that ensure the following:
1. The output list is sorted.
2. The output list is a permutation of the input list.

\subsubsection{Sortedness Specification}

We define a helper function, \texttt{isSorted}, to check whether a list is sorted:

\begin{haskell}
{-@ reflect isSorted @-}
isSorted :: (Ord a) => List a -> Bool
isSorted Nil = True
isSorted (Cons x xs) =
  isSorted xs && case xs of
    Nil        -> True
    Cons x1 _  -> x <= x1
\end{haskell}

The \texttt{isSorted} function is then used to specify and verify the correctness of the \texttt{insert} and \texttt{insertSort} functions.

\subsubsection{Insert Function Specification}

The \texttt{insert} function places an element into a sorted list while maintaining its sortedness:

\begin{haskell}
{-@ insert :: x:_ -> {xs:_ | isSorted xs} 
  -> {ys:_ | isSorted ys && Map_union (singleton x) (bag xs) == bag ys  } @-}
\end{haskell}

\subsubsection{Insertion Sort Specification}

The \texttt{insertSort} function ensures that the output is sorted and is a permutation of the input:

\begin{haskell}
{-@ insertSort :: xs:_ -> {ys:_ | isSorted ys && bag xs == bag ys} @-}
\end{haskell}

Here, \texttt{bag} represents a multiset of elements, used to verify that the output is a permutation of the input.

\subsection{Proofs}
By incorporating the specifications into the insertion sort implementation, we can verify the correctness of the algorithm.
Once we define the specification, we will realize that we need to prove the correctness of the \texttt{insert} function.
As the specification is not enough for the \texttt{LiquidHaskell} to verify the correctness of the \texttt{insert} function, we need to prove the following lemma:

\begin{haskell}
{-@ lem_ins :: y:_ -> {x:_ | y < x} -> {ys:_ | isSorted (Cons y ys)} 
    -> {isSorted (Cons y (insert x ys))} @-}
lem_ins :: (Ord a) => a -> a -> List a -> Bool
lem_ins y x Nil = True
lem_ins y x (Cons y1 ys) = if y1 < x then lem_ins y1 x ys else True
\end{haskell}

This lemma ensures that the \texttt{insert} function maintains the sortedness property.
Then with the use of \texttt{withProof}, we can use the lemma to prove the correctness of the \texttt{insert} function:

\begin{haskell}
{-@ reflect insert @-}
{-@ insert :: x:_ -> {xs:_ | isSorted xs} 
  -> {ys:_ | isSorted ys && Map_union (singleton x) (bag xs) == bag ys  } @-}
insert :: (Ord a) => a -> List a -> List a
insert x Nil = Cons x Nil
insert x (Cons y ys)
  | x <= y = Cons x (Cons y ys)
  | otherwise = Cons y (insert x ys) `withProof` lem_ins y x ys
\end{haskell}

\subsubsection{Proof of Insertion Sort Correctness}

The correctness of \texttt{insertSort} is established by combining the correctness of \texttt{insert} and ensuring that the output satisfies 
both the sortedness and permutation properties.

\begin{haskell}
{-@ insertSort :: xs:_ -> {ys:_ | isSorted ys && bag xs == bag ys} @-}
insertSort :: (Ord a) => List a -> List a
insertSort Nil = Nil
insertSort (Cons x xs) = insert x (insertSort xs)
\end{haskell}

By verifying these properties using \texttt{LiquidHaskell}, we ensure that insertion 
sort is functionally correct and meets the desired specifications.

\section{Conclusions}

\texttt{LiquidHaskell} combines refinement types, code reflection, and PLE to offer a practical approach to program verification within an existing language. By leveraging SMT solvers for decidable theories and PLE to automate equational reasoning, \texttt{LiquidHaskell} aims to simplify the process of verifying program correctness when compared to other tools.
\label{sec:conclusions}
\newpage
\section*{Acknowledgements}
We would like to express our gratitude to the developers and maintainers of \texttt{LiquidHaskell}, whose research and 
documentation provided the foundation for this work.

Additionally, we acknowledge the use of AI-assisted tools throughout the preparation of this report. 
GitHub Copilot was employed for minor rewording and auto-completion in code snippets, 
helping streamline the coding process. For better comprehension of academic papers and extracting key information, 
we leveraged ChatGPT and NotebookLM. ChatGPT was especially usefull finding grammatical errors and suggesting improvements in the text.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\nocite{*}
\bibliographystyle{eptcs}
\bibliography{references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
